#ifndef OVPS_TEST_HELPER_H_
#define OVPS_TEST_HELPER_H_

#include <thrust/device_vector.h>
#include <vector>

  void vfill(thrust::device_vector<double>& v) {
    thrust::fill(v.begin(), v.end(), -1);
  }
  
  std::vector<double> get_vector(thrust::device_vector<double>& v) {
    std::vector<double> w(v.size());
    thrust::copy(v.begin(), v.end(), w.begin());
    return w;
  }
  
  void vfill(std::vector<double>& v) {
    std::fill(v.begin(), v.end(), -1);
  }
  
  std::vector<double> get_vector(std::vector<double> v) {
    return v;
  }

std::vector<double> make_psi(int n_electron_pairs, int n_orbitals, double sign) {
  // the values of psi are such that they produce green's functions traces that
  // are polygamma values multipled by a factor that depends on the row/col of 
  // the trace
  std::vector<double> v(n_electron_pairs * n_orbitals);
  for (int col = 0; col < n_electron_pairs; col++) {
    for (int row = 0; row < n_orbitals; row++) {
      v[col * n_orbitals + row] = sign * 1.0 / ((col+1) * (row+1));
    }
  }
  return v;
}
  
double PolyGamma(int n, int z) {
  // polygamma is hard to implement......
  // values generated by mathematic
  assert(n >= 0 && n <= 4 && z >= 1 && z <= 20);
  std::vector<std::vector<double>> values = {
    {-0.5772156649015329, 1.644934066848226, -2.404113806319189, 6.493939402266829, -24.88626612344088},
    {0.4227843350984671, 0.6449340668482264, -0.4041138063191886, 0.4939394022668291, -0.8862661234408782},
    {0.9227843350984671, 0.3949340668482264, -0.1541138063191886, 0.1189394022668291, -0.1362661234408782},
    {1.256117668431800, 0.2838229557371153, -0.08003973224511450, 0.04486532819275508, -0.03750069134211280},
    {1.506117668431800, 0.2213229557371153, -0.04878973224511450, 0.02142782819275508, -0.01406319134211280},
    {1.706117668431800, 0.1813229557371153, -0.03278973224511450, 0.01182782819275508, -0.006383191342112800},
    {1.872784335098467, 0.1535451779593375, -0.02353047298585524, 0.007198198563125445, -0.003296771589026380},
    {2.015641477955610, 0.1331370146940314, -0.01769956919576777, 0.004699239795945104, -0.001868795150637614},
    {2.140641477955610, 0.1175120146940314, -0.01379331919576777, 0.003234396045945104, -0.001136373275637614},
    {2.251752589066721, 0.1051663356816857, -0.01104983497080207, 0.002319901304289868, -0.0007299311682352866},
    {2.351752589066721, 0.09516633568168575, -0.009049834970802067, 0.001719901304289868, -0.0004899311682352866},
    {2.442661679975812, 0.08690187287176839, -0.007547205368998912, 0.001310093231070826, -0.0003409100507010894},
    {2.525995013309145, 0.07995742842732395, -0.006389797961591505, 0.001020741379218974, -0.0002444594334171388},
    {2.602918090232222, 0.07404026866401034, -0.005479465690312488, 0.0008106647012315087, -0.0001798204555748417},
    {2.674346661660794, 0.06893822784768381, -0.004750602716551555, 0.0006544797782827373, -0.0001351961918751928},
    {2.741013328327460, 0.06449378340323936, -0.004158010123958962, 0.0005359612597642188, -0.0001035912536035878},
    {2.803513328327460, 0.06058753340323936, -0.003669728873958962, 0.0004444085253892188, -0.00008070307000983783},
    {2.862336857739225, 0.05712732579078261, -0.003262645625434639, 0.0003725703050613971, -0.00006379995934446801},
    {2.917892413294781, 0.05404090603769619, -0.002919710097313926, 0.0003154143837079449, -0.00005109864348814529},
    {2.970523992242149, 0.05127082293520312, -0.002628122402314655, 0.0002693742213396389, -0.00004140597772639667} 
  };
  return values[z-1][n];
}

double PolyGamma_Difference(int start, int stop, int n) {
  double fac = -1;
  for (int i = 2; i <= n; i++) {
    fac *= -i;
  }
  double polygamma =  PolyGamma(n, stop + 1) - PolyGamma(n, start + 1);
  return polygamma / fac;
}

#endif  // OVPS_TEST_HELPER_H_
