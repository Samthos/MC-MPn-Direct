#include "test_helper.h"

/*
   the fill heper function fill a vector with -1.0
*/

void vfill(std::vector<double>& v) {
  std::fill(v.begin(), v.end(), -1);
}


/*
   returns a copy of the argument as std::vector<double>
*/
std::vector<double> get_vector(thrust::device_vector<double>& v) {
  std::vector<double> w(v.size());
  thrust::copy(v.begin(), v.end(), w.begin());
  return w;
}

std::vector<double> make_psi(int n_electron_pairs, int n_orbitals, double sign) {
  // the values of psi are such that they produce green's functions traces that
  // are polygamma values multipled by a factor that depends on the row/col of 
  // the trace
  std::vector<double> v(n_electron_pairs * n_orbitals);
  for (int col = 0; col < n_electron_pairs; col++) {
    for (int row = 0; row < n_orbitals; row++) {
      v[col * n_orbitals + row] = sign * 1.0 / ((col+1) * (row+1));
    }
  }
  return v;
}
  
double PolyGamma(int n, int z) {
  // polygamma is hard to implement......
  // values generated by mathematic
  if (n < 0 && n > 20) {
    printf("n out of range with value %i; Good values 0 <= n <= 20\n", n);
    exit(0);
  }
  std::vector<double> values = {
    -0.5772156649015329, -1.644934066848226,
    -1.202056903159594, -1.082323233711138,
    -1.036927755143370, -1.017343061984449,
    -1.008349277381923, -1.004077356197944,
    -1.002008392826082, -1.000994575127818,
    -1.000494188604119, -1.000246086553308,
    -1.000122713347578, -1.000061248135059,
    -1.000030588236307, -1.000015282259409,
    -1.000007637197638, -1.000003817293265,
    -1.000001908212717, -1.000000953962034,
    -1.000000476932987, -1.000000238450503
  };

  double factorial = 1.0;
  for (int i = 1; i <= n; i++) {
    factorial *= -i;
  }

  double polygamma_value = values[n];
  for (int i = 1; i < z; i++) {
    polygamma_value += 1.0 / pow(i, n+1);
  }
  polygamma_value *= factorial;

  return polygamma_value;
}

double PolyGamma_Difference(int start, int stop, int n) {
  double fac = 1;
  for (int i = 1; i <= n; i++) {
    fac *= -i;
  }
  double polygamma =  PolyGamma(n, stop + 1) - PolyGamma(n, start + 1);
  return polygamma / fac;
}

#ifdef HAVE_CUDA
void vfill(thrust::device_vector<double>& v) {
  thrust::fill(v.begin(), v.end(), -1);
}

std::vector<double> get_vector(std::vector<double> v) {
  return v;
}
#endif
